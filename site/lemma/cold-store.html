<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Logodaedaly — Toggle Flip</title>
  <style>
    :root{
      --bg: #ffffff; --fg: #111111; --muted: #5a5a5a; --muted-2:#7a7a7a;
      --border:#d7d7d7; --border-2:#e6e6e6; --panel:#fafafa; --focus:#111111;
      --pill:#f2f2f2; --danger:#b00020; --ok:#0a5c2b; --accent: #111111;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --radius: 12px; --radius-sm: 8px;
    }
    @media (prefers-color-scheme: dark){
      :root{
        --bg:#0c0c0c; --fg:#f1f1f1; --muted:#bdbdbd; --muted-2:#9a9a9a;
        --border:#2a2a2a; --border-2:#1f1f1f; --panel:#101010; --focus:#f1f1f1;
        --pill:#171717; --danger:#ff4d6d; --ok:#3ddc97; --accent: #f1f1f1;
      }
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body { background: var(--bg); color: var(--fg); font-family: var(--sans); line-height: 1.4; font-size: 14px; }
    
    .app { height: 100vh; display: flex; flex-direction: column; }
    header { display: flex; align-items: center; justify-content: space-between; padding: 12px 20px; border-bottom: 1px solid var(--border); background: var(--bg); z-index: 50; flex-shrink: 0; }
    .product-name { font-size: 13px; font-weight: 600; text-transform: uppercase; cursor: pointer; letter-spacing: 0.05em; }
    nav { display: flex; gap: 20px; }
    nav a { font-size: 13px; color: var(--muted); cursor: pointer; text-decoration: none; font-weight: 500; }
    nav a.active { color: var(--fg); border-bottom: 2px solid var(--fg); padding-bottom: 4px; }
    
    main { position: relative; flex: 1; overflow: hidden; display: flex; flex-direction: column; }
    
    /* Landing Animation */
    #landingLayer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; background: var(--bg); overflow: hidden; }
    #centerSearchContainer { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); width: 400px; z-index: 20; background: var(--bg); padding: 20px; border-radius: var(--radius); border: 1px solid var(--border); box-shadow: 0 10px 40px rgba(0,0,0,0.05); }
    .drifting-word { position: absolute; font-size: 14px; color: var(--muted); cursor: pointer; user-select: none; white-space: nowrap; transition: color 0.2s; padding: 5px 10px; border-radius: 99px; }
    .drifting-word:hover { color: var(--fg); background: var(--panel); z-index: 15; }

    /* Dictionary View */
    #dictionaryView { display: none; height: 100%; padding: 20px; box-sizing: border-box; }
    #dictionaryView.active { display: block; }
    .grid-layout { display: grid; grid-template-columns: 260px 1fr; gap: 50px; height: 100%; max-width: 960px; margin: 0 auto; }
    aside, #entryPanel { overflow-y: auto; padding-right: 5px; height: 100%; }

    /* UI Elements */
    .input { width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: var(--bg); outline: none; color: var(--fg); }
    .btn { padding: 8px 14px; border-radius: var(--radius-sm); border: 1px solid var(--border); background: var(--bg); font-size: 13px; cursor: pointer; display: inline-flex; align-items: center; gap: 6px; color: var(--fg); font-weight: 500; }
    .btn.primary { background: var(--fg); color: var(--bg); border-color: var(--fg); }
    .btn.subtle { border: none; background: transparent; color: var(--muted); }
    .btn.subtle:hover { color: var(--fg); background: var(--pill); }
    .btn.danger { background: #fff0f0; color: var(--danger); border-color: var(--danger); }
    .btn.danger:hover { background: var(--danger); color: white; }
    .btn-circle { width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border); background: var(--bg); color: var(--fg); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; font-size: 18px; }
    .btn-circle:hover { border-color: var(--fg); background: var(--panel); }
    .btn-circle.active { background: var(--fg); color: var(--bg); border-color: var(--fg); }
    .btn-circle.added { background: var(--ok); border-color: var(--ok); color: white; cursor: default; }

    .results-card { border: 1px solid var(--border); border-radius: var(--radius); overflow: hidden; margin-top: 12px; display: none; background: var(--bg); max-height: 400px; overflow-y: auto; }
    .result-item { padding: 10px 14px; border-bottom: 1px solid var(--border-2); cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
    .result-item:hover { background: var(--panel); }

    /* Cards */
    .entry-card { border: 1px solid var(--border); border-radius: var(--radius); background: var(--bg); margin-bottom: 16px; overflow: hidden; transition: border-color 0.2s; }
    .entry-card.selection-mode { border-color: var(--fg); box-shadow: 0 0 0 1px var(--fg); }
    .entry-header { padding: 16px 20px; border-bottom: 1px solid var(--border); background: var(--panel); }
    .lemma-text { font-size: 28px; font-weight: 700; letter-spacing: -0.02em; }
    .pill { padding: 2px 8px; border-radius: 99px; background: var(--bg); border: 1px solid var(--border); font-size: 11px; font-family: var(--mono); color: var(--muted); }
    
    .def-card { padding: 12px; border: 1px solid var(--border-2); border-radius: var(--radius-sm); background: var(--bg); margin: 10px 20px; }
    .def-card.disabled { opacity: 0.5; pointer-events: none; }
    .def-block { display: block; line-height: 1.5; font-weight: 400; color: var(--fg); }
    .example-block { margin-top: 6px; padding-left: 10px; border-left: 2px solid var(--border); font-size: 13px; color: var(--muted); font-style: italic; display: block; }
    
    .def-row, .example-row { display: flex; gap: 10px; align-items: flex-start; }
    .example-row.disabled { opacity: 0.5; pointer-events: none; }
    .example-text { font-size: 13px; color: var(--muted); font-style: italic; }
    
    .chk { appearance: none; width: 16px; height: 16px; border: 1px solid var(--muted); border-radius: 3px; cursor: pointer; display: flex; align-items: center; justify-content: center; background: transparent; flex-shrink: 0; margin-top: 3px; }
    .chk:checked { border-color: var(--fg); }
    .chk:checked::after { content: '✓'; font-size: 12px; color: var(--fg); font-weight: 700; line-height: 1; }
    .chk:disabled { opacity: 0.3; cursor: not-allowed; }

    .pos-group-header { margin: 20px 20px 8px 20px; font-size: 13px; font-weight: 700; color: var(--fg); text-transform: capitalize; border-bottom: 2px solid var(--border-2); padding-bottom: 6px; letter-spacing: 0.02em; }
    .expand-control { padding: 12px 20px; display: flex; align-items: center; gap: 15px; border-top: 1px solid var(--border-2); margin-top: 10px; background: var(--panel); }
    .expand-btn { font-size: 13px; font-weight: 600; color: var(--fg); cursor: pointer; background: none; border: none; padding: 0; text-decoration: underline; }
    .hidden-sense { display: none; }

    .notes-toggle { margin: 10px 20px; cursor: pointer; font-size: 12px; font-weight: 600; color: var(--muted); display: inline-flex; align-items: center; gap: 5px; }
    .notes-container { margin: 0 20px 20px 20px; display: none; }
    .notes-container.open { display: block; }
    .notes-area { width: 100%; min-height: 80px; padding: 10px; border: 1px solid var(--border-2); border-radius: var(--radius-sm); font-family: var(--sans); font-size: 13px; background: var(--panel); color: var(--fg); resize: vertical; }
    .notes-section { margin: 10px 20px 20px 20px; padding-top: 10px; border-top: 1px solid var(--border-2); }
    .notes-label { font-size: 11px; font-weight: 700; text-transform: uppercase; color: var(--muted); margin-bottom: 6px; }

    /* Review - Clean Back */
    .flashcard-container { perspective: 1000px; width: 100%; max-width: 600px; margin: 20px auto; }
    .flashcard-inner { position: relative; width: 100%; transform-style: preserve-3d; transition: transform 0.6s; border-radius: var(--radius); border: 1px solid var(--border); background: var(--bg); min-height: 400px; display: flex; flex-direction: column; }
    .flashcard-container.flipped .flashcard-inner { transform: rotateY(180deg); }
    .card-face { position: absolute; top: 0; left: 0; width: 100%; height: 100%; backface-visibility: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px; border-radius: var(--radius); background: var(--bg); }
    .card-back { transform: rotateY(180deg); overflow-y: auto; display: block; text-align: left; padding: 40px; }
    
    /* Clean Review Overrides */
    .review-content .def-card { border: none; padding: 0 0 20px 0; margin: 0; background: transparent; box-shadow: none; }
    .review-content .pos-group-header { margin: 0 0 8px 0; border: none; font-size: 11px; }
    .review-content .notes-section { margin: 20px 0 0 0; padding-top: 20px; border-top: 1px solid var(--border-2); }

    .review-controls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; max-width: 400px; margin: 0 auto 40px auto; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
    .review-controls.visible { opacity: 1; pointer-events: auto; }
    .review-btn { display: flex; flex-direction: column; align-items: center; padding: 12px; border-radius: var(--radius-sm); border: 1px solid var(--border); background: var(--bg); cursor: pointer; transition: background 0.1s; }
    .review-btn:hover { background: var(--panel); }
    .review-label { font-weight: 600; font-size: 14px; margin-bottom: 4px; }
    .review-time { font-size: 11px; color: var(--muted); }
    .btn-again { border-color: var(--danger); color: var(--danger); } .btn-again:hover { background: #fff0f0; }
    .btn-good { border-color: var(--ok); color: var(--ok); } .btn-good:hover { background: #f0fff4; }

    /* Dashboard */
    .tab-content { display: none !important; height: 100%; }
    .tab-content.active { display: block !important; }
    #deckDashboard { height: 100%; overflow-y: auto; }
    #deckBrowser { display: none; height: 100%; padding: 20px; box-sizing: border-box; }
    .browser-container { height: 100%; display: flex; flex-direction: column; max-width: 1100px; margin: 0 auto; }
    .browser-grid { display: grid; grid-template-columns: 280px 1fr; gap: 20px; flex: 1; overflow: hidden; }
    .browser-sidebar { background: var(--bg); border: 1px solid var(--border); border-radius: var(--radius); display: flex; flex-direction: column; overflow: hidden; }
    .browser-header { padding: 15px; border-bottom: 1px solid var(--border); background: var(--panel); }
    #cardList { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex: 1; }
    #cardList li { padding: 12px 15px; border-bottom: 1px solid var(--border-2); cursor: pointer; font-size: 13px; font-weight: 500; display: flex; justify-content: space-between; align-items: center; }
    #cardList li:hover { background: var(--panel); }
    #cardList li.selected { background: var(--fg); color: var(--bg); }
    .browser-editor { border: 1px solid var(--border); border-radius: var(--radius); display: flex; flex-direction: column; background: var(--bg); overflow: hidden; }
    .editor-scroll-area { flex: 1; overflow-y: auto; padding: 20px; }
    .editor-section { margin-bottom: 25px; }
    .editor-label { font-size: 11px; text-transform: uppercase; font-weight: 700; color: var(--muted); margin-bottom: 8px; letter-spacing: 0.05em; }
    .editor-actions { padding: 15px 20px; border-top: 1px solid var(--border); background: var(--panel); display: flex; justify-content: space-between; }

    #toastContainer { position: fixed; bottom: 20px; right: 20px; z-index: 1000; display: flex; flex-direction: column; gap: 10px; }
    .toast { padding: 12px 16px; background: var(--fg); color: var(--bg); border-radius: var(--radius-sm); font-size: 13px; display: flex; align-items: center; gap: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); animation: fadeUp 0.3s ease; }
    .toast-action { color: var(--ok); font-weight: 600; cursor: pointer; text-decoration: underline; margin-left: auto; }
    @keyframes fadeUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    .lock-wrapper { display: flex; align-items: center; gap: 8px; cursor: pointer; opacity: 0.6; transition: opacity 0.2s; }
    .lock-wrapper.active { opacity: 1; color: var(--ok); }
    .lock-icon { width: 16px; height: 16px; border: 1.5px solid currentColor; border-radius: 50%; position: relative; }
    .lock-wrapper.active .lock-icon { background: currentColor; }

    /* Auth Modal */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; align-items: center; justify-content: center; z-index: 2000; }
    .modal-backdrop.open { display: flex; }
    .modal { background: var(--bg); color: var(--fg); border: 1px solid var(--border); border-radius: var(--radius); width: 360px; max-width: calc(100% - 30px); padding: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.2); }
    .modal h3 { margin: 0 0 12px 0; font-size: 18px; }
    .modal .field { margin-bottom: 10px; }
    .modal .field label { display: block; font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em; color: var(--muted); margin-bottom: 6px; }
    .modal .actions { display: flex; gap: 8px; margin-top: 12px; }
    .modal .link { font-size: 12px; color: var(--muted); cursor: pointer; text-decoration: underline; }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="product-name" onclick="goHome()">Logodaedaly</div>
    <nav id="mainNav">
      <a data-tab="home" class="active">Dictionary</a>
      <a data-tab="review">Dashboard</a>
    </nav>
    <div style="display:flex; gap:8px; align-items:center;">
      <span id="authStatus" style="font-size:12px; color:var(--muted);"></span>
      <button class="btn" id="btnLogin" onclick="loginFlow()">Login</button>
      <button class="btn" id="btnSync" onclick="saveProgress()" style="display:none;">Sync</button>
      <button class="btn" id="btnLogout" onclick="logoutFlow()" style="display:none;">Logout</button>
    </div>
  </header>
  
  <main>
    <div id="landingLayer">
      <div id="centerSearchContainer">
        <input type="search" id="landingSearch" class="input" placeholder="Search dictionary..." autocomplete="off" style="font-size:16px; padding:14px;">
        <div class="results-card" id="landingResults" style="max-height:300px;"></div>
      </div>
    </div>

    <div id="dictionaryView">
      <div class="grid-layout">
        <aside>
          <input type="search" id="searchInput" class="input" placeholder="Search..." autocomplete="off">
          <div class="results-card" id="resultsCard"><div id="resultsList"></div></div>
        </aside>
        <div id="entryPanel"></div>
      </div>
    </div>

    <section id="tab-review" class="tab-content">
      <div id="deckDashboard">
        <div style="max-width: 800px; margin: 0 auto; padding-top: 40px; padding-bottom:40px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:30px;">
            <h1 style="margin:0; font-size:24px;">Deck Dashboard</h1>
            <div style="display:flex; gap:10px;">
               <select id="dashboardDeckSelect" class="input" style="width:auto;" onchange="updateDashboard()"></select>
               <button class="btn" onclick="exportDeckToAnki()">Export Anki</button>
               <button class="btn" onclick="createNewDeckInPlace()">+ New Deck</button>
            </div>
          </div>
          <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 40px;">
            <div style="padding:30px; border:1px solid var(--border); border-radius:var(--radius); text-align:center;">
              <div id="dashDueCount" style="font-size:48px; font-weight:700;">0</div>
              <div style="color:var(--muted); margin-bottom:20px;">Cards Due Now</div>
              <div id="dashboardActionBtn" style="margin-top:10px; display:flex; justify-content:center;"></div>
            </div>
            <div style="padding:30px; border:1px solid var(--border); border-radius:var(--radius); text-align:center;">
               <div id="dashTotalCount" style="font-size:48px; font-weight:700;">0</div>
               <div style="color:var(--muted); margin-bottom:20px;">Total Cards</div>
               <button class="btn" onclick="showBrowser()">Browse Cards</button>
            </div>
          </div>
        </div>
      </div>

      <div id="deckBrowser">
        <div class="browser-container">
          <div style="margin-bottom:15px; display:flex; align-items:center; gap:15px;">
            <button class="btn subtle" onclick="closeBrowser()">← Back to Dashboard</button>
            <h3 style="margin:0;">Card Browser</h3>
          </div>
          <div class="browser-grid">
            <aside class="browser-sidebar">
              <div class="browser-header">
                <input type="search" id="browserSearch" class="input" placeholder="Search cards..." oninput="filterBrowser(this.value)">
              </div>
              <ul id="cardList"></ul>
            </aside>
            <section class="browser-editor">
              <div id="editorPlaceholder" style="display:flex; align-items:center; justify-content:center; height:100%; color:var(--muted); font-style:italic;">Select a card to edit</div>
              <div id="editorContent" style="display:none; height:100%; flex-direction:column;">
                 <div class="editor-scroll-area">
                   <div class="editor-section">
                     <div class="editor-label">Front</div>
                     <div id="editorFront" style="font-size:24px; font-weight:700; padding-bottom:10px;"></div>
                   </div>
                   <div class="editor-section">
                     <div class="editor-label">Back</div>
                     <div id="editorBack" class="entry-card selection-mode" style="border:none; box-shadow:none;"></div>
                   </div>
                 </div>
                 <div class="editor-actions">
                   <button class="btn danger" onclick="deleteCardFromEditor()">Delete Card</button>
                   <button class="btn primary" onclick="saveCardFromEditor()">Save Changes</button>
                 </div>
              </div>
            </section>
          </div>
        </div>
      </div>

      <div id="reviewSession" style="display:none;">
        <div style="max-width:600px; margin:0 auto; display:flex; justify-content:space-between; align-items:center; padding:10px 0;">
          <button class="btn subtle" onclick="quitSession()">✕ Quit</button>
          <div style="font-weight:600; font-size:12px; color:var(--muted);" id="reviewProgress"></div>
        </div>
        <div class="flashcard-container" id="activeFlashcard" onclick="flipCard()">
          <div class="flashcard-inner">
            <div class="card-face card-front">
              <div style="position:absolute; top:15px; right:15px; z-index:10; display:flex; gap:5px;">
                 <button class="btn subtle" style="padding:4px;" onclick="event.stopPropagation(); editCurrentCard()">Edit</button>
                 <button class="btn subtle danger" style="padding:4px;" onclick="event.stopPropagation(); deleteCurrentCard()">Del</button>
              </div>
              <div style="font-size:12px; color:var(--muted); margin-bottom:20px; text-transform:uppercase; letter-spacing:0.05em;">Recall the definition</div>
              <div class="lemma-large" id="cardFrontLemma"></div>
              <div id="cardFrontContext" style="color:var(--muted); margin-top:10px; font-style:italic;"></div>
            </div>
            <div class="card-face card-back" id="cardBackContent"></div>
          </div>
        </div>
        <div class="review-controls" id="reviewControls">
          <button class="review-btn btn-again" onclick="rateCard(1)"><span class="review-label">Again (1)</span><span class="review-time" id="time-again">1m</span></button>
          <button class="review-btn" onclick="rateCard(3)"><span class="review-label">Good (2)</span><span class="review-time" id="time-good">1d</span></button>
          <button class="review-btn btn-good" onclick="rateCard(5)"><span class="review-label">Easy (3)</span><span class="review-time" id="time-easy">4d</span></button>
        </div>
      </div>
    </section>
  </main>
  
  <div id="toastContainer"></div>
</div>

<div id="authModal" class="modal-backdrop" onclick="closeAuthModal(event)">
  <div class="modal">
    <h3 id="authTitle">Sign in</h3>
    <div class="field">
      <label for="authEmail">Email</label>
      <input id="authEmail" class="input" type="email" autocomplete="email">
    </div>
    <div class="field">
      <label for="authPassword">Password</label>
      <input id="authPassword" class="input" type="password" autocomplete="current-password">
    </div>
    <div class="actions">
      <button class="btn primary" id="authSubmit" onclick="submitAuth()">Sign in</button>
      <button class="btn" onclick="loginWithGoogle()">Google</button>
    </div>
    <div style="margin-top:10px; display:flex; justify-content:space-between; align-items:center;">
      <span class="link" id="authToggle" onclick="toggleAuthMode()">Create account</span>
      <span class="link" id="authResend" onclick="resendConfirmation()" style="display:none;">Resend confirmation</span>
      <span class="link" onclick="closeAuthModal()">Cancel</span>
    </div>
  </div>
</div>

<script>window.__LEMMA_DATA__ = {"lemma": "cold-store", "ipa": "/ˈkoʊld stoʊr/", "pos": "noun/verb", "freq": 4, "morphology": null, "etymology": "From English 'cold' + 'store'.", "related": [], "senses": [{"id": 263189, "attr": "pos=noun", "def": "A facility or building used for the refrigerated storage of goods, especially food.", "ex": "The company invested in a new cold-store to expand its frozen produce line."}, {"id": 263193, "attr": "pos=verb", "def": "To store goods in a cold-store.", "ex": "They decided to cold-store the surplus harvest until market prices improved."}]};document.title = "cold-store \u2014 Logodaedaly";</script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
const API_BASE = window.__API_BASE__ || `${window.location.origin}/api`;
const POS_MAP = { 'n':'Noun', 'noun':'Noun', 'v':'Verb', 'verb':'Verb', 'vt':'Transitive Verb', 'vi':'Intransitive Verb', 'adj':'Adjective', 'adjective':'Adjective', 'adv':'Adverb', 'adverb':'Adverb', 'prep':'Preposition', 'conj':'Conjunction', 'pron':'Pronoun', 'interj':'Interjection', 'art':'Article', 'num':'Numeral', 'aux':'Auxiliary Verb', 'phrasal':'Phrasal Verb' };

let LEXICON_INDEX = [];
let CURRENT_WORD = null; 
let TEMP_EXPANDED = false;
let SELECTION_MODE = false;
let ALLOW_DUPLICATES = false; 
let EDIT_CARD_ID = null;
let ACTION_STACK = [];
let PENDING_DELETES = {};
let DRIFTERS = [];
let ANIMATION_ID = null;
let RETURN_TO_VIEW = null; 
let SUPABASE = null;
let CURRENT_USER = null;
let AUTH_MODE = "login"; // login | signup
let AUTH_PENDING = null;
let AUTH_POLL_TIMER = null;
let STATIC_MODE = false;
let STATIC_SLUG_MAP = null;

const FALLBACK_WORDS = ["abandon", "ability", "absorb", "abstract", "academic", "accept", "access", "accident"];

let state = {
  deck: JSON.parse(localStorage.getItem('lex_v9_deck') || '[]'),
  decks: JSON.parse(localStorage.getItem('lex_v9_decks') || '["Default"]'),
  notes: JSON.parse(localStorage.getItem('lex_v12_notes') || '{}'),
  queue: [],
  idx: 0,
  currentReviewDeck: 'Default',
  selectedDeckForAdd: 'Default',
  cramMode: false
};

const $ = (s) => document.querySelector(s);

async function init() {
  setupTabs(); setupSearch(); setupShortcuts();
  populateDeckSelects();
  updateDashboard(); 
  initAuth();

  if (window.__LEMMA_DATA__) {
    CURRENT_WORD = window.__LEMMA_DATA__;
    ensureIds(CURRENT_WORD);
    $('#landingLayer').style.display = 'none';
    $('#dictionaryView').classList.add('active');
    $('#tab-review').classList.remove('active');
    $('[data-tab="home"]').classList.add('active');
    $('[data-tab="review"]').classList.remove('active');
    $('#searchInput').value = CURRENT_WORD.lemma || '';
    renderEntry($('#entryPanel'), CURRENT_WORD);
    // Load static manifest for search/navigation on lemma pages.
    try {
      const r2 = await fetch(`${window.location.origin}/manifest.json`);
      if(r2.ok) {
        const manifest = await r2.json();
        STATIC_MODE = true;
        if (Array.isArray(manifest) && manifest.length > 0 && typeof manifest[0] === "object") {
          STATIC_SLUG_MAP = new Map(manifest.map(m => [m.lemma, m.slug]));
          LEXICON_INDEX = manifest.map(m => m.lemma);
        } else {
          LEXICON_INDEX = manifest;
        }
      }
    } catch(e2) {}
    return;
  }
  
  if (window.__STATIC_INDEX__ === true) {
    try {
      const r2 = await fetch(`${window.location.origin}/manifest.json`);
      if(!r2.ok) throw new Error("Static manifest load failed");
      const manifest = await r2.json();
      STATIC_MODE = true;
      if (Array.isArray(manifest) && manifest.length > 0 && typeof manifest[0] === "object") {
        STATIC_SLUG_MAP = new Map(manifest.map(m => [m.lemma, m.slug]));
        LEXICON_INDEX = manifest.map(m => m.lemma);
      } else {
        LEXICON_INDEX = manifest;
      }
    } catch(e2) {
      console.log("Using fallback words for landing");
      LEXICON_INDEX = FALLBACK_WORDS;
    }
    initLandingAnimation();
    return;
  }

  try {
    const r = await fetch(`${API_BASE}/manifest`);
    if(!r.ok) throw new Error("Manifest load failed");
    LEXICON_INDEX = await r.json();
    initLandingAnimation();
  } catch(e) {
    try {
      const r2 = await fetch(`${window.location.origin}/manifest.json`);
      if(!r2.ok) throw new Error("Static manifest load failed");
      const manifest = await r2.json();
      STATIC_MODE = true;
      if (Array.isArray(manifest) && manifest.length > 0 && typeof manifest[0] === "object") {
        STATIC_SLUG_MAP = new Map(manifest.map(m => [m.lemma, m.slug]));
        LEXICON_INDEX = manifest.map(m => m.lemma);
      } else {
        LEXICON_INDEX = manifest;
      }
    } catch(e2) {
      console.log("Using fallback words for landing");
      LEXICON_INDEX = FALLBACK_WORDS;
    }
    initLandingAnimation();
  }
}

function initAuth() {
  const SUPABASE_URL = "https://gwfclfzoeegqvhyvujnm.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd3ZmNsZnpvZWVncXZoeXZ1am5tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1MDY4NzMsImV4cCI6MjA4NjA4Mjg3M30.UxGwbKmU2iRbeE5T0wUjvcxukNQHxpV6960mIfR1n9k";
  SUPABASE = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
      flowType: 'implicit'
    }
  });

  SUPABASE.auth.getSession().then(({ data }) => {
    CURRENT_USER = data.session?.user || null;
    updateAuthUI();
    if (CURRENT_USER) loadProgress();
  });

  // Some browsers need a tick to process the OAuth URL hash.
  setTimeout(async () => {
    const { data } = await SUPABASE.auth.getSession();
    if (data?.session?.user && !CURRENT_USER) {
      CURRENT_USER = data.session.user;
      updateAuthUI();
      loadProgress();
    }
  }, 500);

  // Clean up OAuth hash only after session is confirmed.
  if (window.location.hash && window.location.hash.includes("access_token")) {
    let tries = 0;
    const timer = setInterval(async () => {
      const { data } = await SUPABASE.auth.getSession();
      if (data?.session?.user) {
        window.history.replaceState({}, document.title, window.location.pathname);
        clearInterval(timer);
      } else if (++tries >= 10) {
        clearInterval(timer);
      }
    }, 200);
  }

  SUPABASE.auth.onAuthStateChange((_event, session) => {
    CURRENT_USER = session?.user || null;
    updateAuthUI();
    if (CURRENT_USER) loadProgress();
  });

  // Periodic auto-sync while logged in.
  setInterval(() => {
    if (CURRENT_USER) saveProgress();
  }, 60000);
}

function updateAuthUI() {
  const status = $('#authStatus');
  const loginBtn = $('#btnLogin');
  const logoutBtn = $('#btnLogout');
  const syncBtn = $('#btnSync');
  if (CURRENT_USER) {
    status.textContent = `Signed in`;
    loginBtn.style.display = 'none';
    logoutBtn.style.display = 'inline-flex';
    syncBtn.style.display = 'inline-flex';
  } else {
    status.textContent = '';
    loginBtn.style.display = 'inline-flex';
    logoutBtn.style.display = 'none';
    syncBtn.style.display = 'none';
  }
}

function loginFlow() {
  openAuthModal();
}

function openAuthModal() {
  AUTH_MODE = "login";
  $('#authTitle').textContent = "Sign in";
  $('#authSubmit').textContent = "Sign in";
  $('#authToggle').textContent = "Create account";
  $('#authResend').style.display = 'none';
  $('#authPassword').setAttribute('autocomplete', 'current-password');
  $('#authModal').classList.add('open');
  $('#authEmail').focus();
}

function closeAuthModal(e) {
  if (e && e.target && e.target.id !== "authModal") return;
  $('#authModal').classList.remove('open');
}

function toggleAuthMode() {
  AUTH_MODE = AUTH_MODE === "login" ? "signup" : "login";
  if (AUTH_MODE === "signup") {
    $('#authTitle').textContent = "Create account";
    $('#authSubmit').textContent = "Sign up";
    $('#authToggle').textContent = "I already have an account";
    $('#authResend').style.display = 'inline';
    $('#authPassword').setAttribute('autocomplete', 'new-password');
  } else {
    $('#authTitle').textContent = "Sign in";
    $('#authSubmit').textContent = "Sign in";
    $('#authToggle').textContent = "Create account";
    $('#authResend').style.display = 'none';
    $('#authPassword').setAttribute('autocomplete', 'current-password');
  }
}

async function loginWithGoogle() {
  await SUPABASE.auth.signInWithOAuth({
    provider: 'google',
    options: { redirectTo: `${window.location.origin}${window.location.pathname}` }
  });
}

async function submitAuth() {
  const email = $('#authEmail').value.trim();
  const password = $('#authPassword').value.trim();
  if (!email || !password) {
    showToast("Email and password required");
    return;
  }
  if (AUTH_MODE === "signup") {
    const res = await SUPABASE.auth.signUp({
      email,
      password,
      options: { emailRedirectTo: `${window.location.origin}${window.location.pathname}` }
    });
    if (res.error) showToast(res.error.message);
    else {
      showToast("Check your email to confirm your account.");
      AUTH_PENDING = { email, password, tries: 0 };
      startConfirmPoll();
    }
  } else {
    const { error } = await SUPABASE.auth.signInWithPassword({ email, password });
    if (error) showToast(error.message);
  }
}

async function resendConfirmation() {
  const email = $('#authEmail').value.trim();
  if (!email) {
    showToast("Enter your email first");
    return;
  }
  const { error } = await SUPABASE.auth.resend({
    type: 'signup',
    email,
    options: { emailRedirectTo: `${window.location.origin}${window.location.pathname}` }
  });
  if (error) showToast(error.message);
  else showToast("Confirmation email resent.");
}

function startConfirmPoll() {
  if (!AUTH_PENDING) return;
  if (AUTH_POLL_TIMER) clearInterval(AUTH_POLL_TIMER);
  AUTH_POLL_TIMER = setInterval(async () => {
    if (!AUTH_PENDING) {
      clearInterval(AUTH_POLL_TIMER);
      AUTH_POLL_TIMER = null;
      return;
    }
    AUTH_PENDING.tries += 1;
    const { error } = await SUPABASE.auth.signInWithPassword({
      email: AUTH_PENDING.email,
      password: AUTH_PENDING.password
    });
    if (!error) {
      AUTH_PENDING = null;
      clearInterval(AUTH_POLL_TIMER);
      AUTH_POLL_TIMER = null;
      closeAuthModal();
      return;
    }
    if (AUTH_PENDING.tries >= 24) { // ~2 minutes
      AUTH_PENDING = null;
      clearInterval(AUTH_POLL_TIMER);
      AUTH_POLL_TIMER = null;
      showToast("Still waiting for confirmation. Please sign in once confirmed.");
    }
  }, 5000);
}

async function logoutFlow() {
  if (CURRENT_USER) await saveProgress();
  await SUPABASE.auth.signOut();
  CURRENT_USER = null;
  // Clear local state so logged-out view is empty.
  state.deck = [];
  state.decks = ["Default"];
  state.notes = {};
  localStorage.removeItem('lex_v9_deck');
  localStorage.removeItem('lex_v9_decks');
  localStorage.removeItem('lex_v12_notes');
  populateDeckSelects();
  updateDashboard();
  updateAuthUI();
}

async function saveProgress() {
  if (!CURRENT_USER) return;
  const payload = {
    deck: state.deck,
    decks: state.decks,
    notes: state.notes
  };
  const { error } = await SUPABASE
    .from('user_progress')
    .upsert({ user_id: CURRENT_USER.id, data: payload, updated_at: new Date().toISOString() });
  if (error) showToast("Sync failed");
  else showToast("Synced");
}

async function loadProgress() {
  const { data, error } = await SUPABASE
    .from('user_progress')
    .select('data')
    .eq('user_id', CURRENT_USER.id)
    .single();
  if (error && error.code !== 'PGRST116') {
    showToast("Load failed");
    return;
  }
  if (data && data.data) {
    state.deck = data.data.deck || [];
    state.decks = data.data.decks || ["Default"];
    state.notes = data.data.notes || {};
    localStorage.setItem('lex_v9_deck', JSON.stringify(state.deck));
    localStorage.setItem('lex_v9_decks', JSON.stringify(state.decks));
    localStorage.setItem('lex_v12_notes', JSON.stringify(state.notes));
    populateDeckSelects();
    updateDashboard();
  }
}

// CRITICAL: Robust ID Generator - ALWAYS RUN THIS
function ensureIds(word) {
  if (word && word.senses) {
    word.senses.forEach((s, i) => {
      if(!s.id) s.id = `gen_${i}`;
      if(s.ex && !s.ex_id) s.ex_id = `ex_${i}`;
    });
  }
}

function goHome() {
  $('#landingLayer').style.display = 'block';
  $('#dictionaryView').classList.remove('active');
  $('#tab-review').classList.remove('active');
  $('[data-tab="home"]').classList.add('active');
  $('[data-tab="review"]').classList.remove('active');
  initLandingAnimation();
}

function initLandingAnimation() {
  const container = $('#landingLayer');
  document.querySelectorAll('.drifting-word').forEach(e => e.remove());
  if (ANIMATION_ID) cancelAnimationFrame(ANIMATION_ID);
  
  const source = LEXICON_INDEX.length > 0 ? LEXICON_INDEX : FALLBACK_WORDS;
  const count = Math.min(8, source.length); 
  DRIFTERS = [];

  const searchBox = $('#centerSearchContainer').getBoundingClientRect();
  const pad = 20;
  const maxX = window.innerWidth;
  const maxY = window.innerHeight;
  
  for(let i=0; i<count; i++) {
    const word = source[Math.floor(Math.random() * source.length)];
    const el = document.createElement('div'); el.className = 'drifting-word'; el.textContent = word; el.onclick = () => { selectWord(word); };
    // Place words outside the search box area.
    let x = 0, y = 0, tries = 0;
    do {
      x = Math.random() * (maxX - 100);
      y = Math.random() * (maxY - 100);
      tries++;
    } while (
      tries < 50 &&
      x < (searchBox.right + pad) &&
      (x + 100) > (searchBox.left - pad) &&
      y < (searchBox.bottom + pad) &&
      (y + 30) > (searchBox.top - pad)
    );
    el.style.transform = `translate(${x}px, ${y}px)`; container.appendChild(el);
    el.onmouseenter = () => { el.dataset.frozen = "true"; }; el.onmouseleave = () => { el.dataset.frozen = "false"; };
    DRIFTERS.push({ el, x, y, vx: (Math.random()-0.5)*0.8, vy: (Math.random()-0.5)*0.8, w:0, h:0 });
  }
  animateDrifters();
}

function animateDrifters() {
  const searchBox = $('#centerSearchContainer').getBoundingClientRect();
  const maxX = window.innerWidth; const maxY = window.innerHeight;
  DRIFTERS.forEach(d => {
    if (d.el.dataset.frozen === "true") return;
    if (d.w === 0) { const r = d.el.getBoundingClientRect(); d.w = r.width; d.h = r.height; }
    d.x += d.vx; d.y += d.vy;
    if (d.x <= 0 || d.x + d.w >= maxX) d.vx *= -1; if (d.y <= 0 || d.y + d.h >= maxY) d.vy *= -1;
    if (d.x < searchBox.right && d.x + d.w > searchBox.left && d.y < searchBox.bottom && d.y + d.h > searchBox.top) {
        const centerX = d.x + d.w/2; const centerY = d.y + d.h/2; const boxCenterX = searchBox.left + searchBox.width/2; const boxCenterY = searchBox.top + searchBox.height/2;
        if (Math.abs(centerX - boxCenterX) > Math.abs(centerY - boxCenterY)) d.vx *= -1; else d.vy *= -1;
    }
    d.el.style.transform = `translate(${d.x}px, ${d.y}px)`;
  });
  if ($('#landingLayer').style.display !== 'none') ANIMATION_ID = requestAnimationFrame(animateDrifters);
}

function normalizePos(raw) {
  if (!raw) return null;
  let clean = raw.split(/[;\s]+/)[0].trim().replace(/^pos\s*=\s*/i, '').replace(/[.\[\]\(\)\{\}]/g, '').trim().toLowerCase();
  return POS_MAP[clean] || clean.charAt(0).toUpperCase() + clean.slice(1);
}

function slugifyLemma(text) {
  if (!text) return "untitled";
  return text
    .toString()
    .normalize("NFKC")
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "") || "untitled";
}

function getSlugForLemma(lemma) {
  if (STATIC_SLUG_MAP && STATIC_SLUG_MAP.has(lemma)) {
    return STATIC_SLUG_MAP.get(lemma);
  }
  return slugifyLemma(lemma);
}

function tsvEscape(val) {
  // Preserve HTML exactly; only escape quotes and normalize CRLF.
  return `"${String(val ?? '').replace(/\r\n/g, '\n').replace(/"/g, '""')}"`;
}

function getAnkiStyleBlock() {
  return `
<style>
  :root{
    --bg: #ffffff; --fg: #111111; --muted:#5a5a5a; --border:#d7d7d7; --border-2:#e6e6e6;
    --panel:#fafafa; --radius: 12px; --radius-sm: 8px;
    --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  }
  .anki-root{ font-family: var(--sans); color: var(--fg); background: var(--bg); }
  .anki-card{ border:1px solid var(--border); border-radius: var(--radius); padding: 28px 26px; }
  .review-content .pos-group-header{ margin: 0 0 10px 0; font-size: 13px; font-weight: 700; color: var(--fg); text-transform: capitalize; letter-spacing: 0.02em; }
  .review-content .def-card{ border: none; padding: 0 0 18px 0; margin: 0; background: transparent; box-shadow: none; }
  .review-content .def-block{ display:block; line-height: 1.6; font-size: 15px; }
  .review-content .example-block{ margin-top: 8px; padding-left: 0; border-left: none; font-size: 14px; color: var(--muted); font-style: italic; display:block; }
  .review-content .notes-section{ margin-top: 18px; padding-top: 18px; border-top: 1px solid var(--border-2); }
  .review-content .notes-label{ font-size: 11px; font-weight: 700; text-transform: uppercase; color: var(--muted); margin-bottom: 6px; letter-spacing: 0.05em; }
</style>`;
}

function buildReviewHtml(wordData, card) {
  const container = document.createElement('div');
  renderEntry(container, wordData, true, card);
  const styleBlock = getAnkiStyleBlock();
  return `${styleBlock}<div class="anki-root"><div class="anki-card">${container.innerHTML}</div></div>`;
}

async function exportDeckToAnki() {
  const deckName = $('#dashboardDeckSelect').value || state.decks[0];
  const cards = state.deck.filter(c => c.deck === deckName && !PENDING_DELETES[c.id]);
  if (cards.length === 0) {
    showToast("No cards to export");
    return;
  }

  showToast("Preparing export...");
  const rows = [];
  for (const card of cards) {
    try {
      const r = await fetch(`${API_BASE}/word/${card.lemma}`);
      if (!r.ok) throw new Error("Word not found");
      const wordData = await r.json();
      ensureIds(wordData);
      const backHtml = buildReviewHtml(wordData, card);
      rows.push(`${tsvEscape(card.lemma)}\t${tsvEscape(backHtml)}`);
    } catch (e) {
      rows.push(`${tsvEscape(card.lemma)}\t${tsvEscape('(Missing data)')}`);
    }
  }

  const tsv = rows.join('\n');
  const blob = new Blob([tsv], { type: 'text/tab-separated-values;charset=utf-8' });
  const safeName = deckName.replace(/[^a-z0-9_-]+/gi, '_');
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `lexdb_${safeName}_anki.tsv`;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    URL.revokeObjectURL(a.href);
    a.remove();
  }, 0);
}

async function selectWord(l) {
  if (STATIC_MODE) {
    const slug = getSlugForLemma(l);
    window.location.href = `${window.location.origin}/lemma/${slug}.html`;
    return;
  }
  $('#landingLayer').style.display = 'none'; 
  $('#dictionaryView').classList.add('active'); 
  $('#tab-review').classList.remove('active');
  $('#resultsCard').style.display = 'none'; 
  $('#landingResults').style.display = 'none';
  
  TEMP_EXPANDED = false; SELECTION_MODE = false; ALLOW_DUPLICATES = false; EDIT_CARD_ID = null;
  try {
    const r = await fetch(`${API_BASE}/word/${l}`);
    if(!r.ok) throw new Error("Word not found");
    CURRENT_WORD = await r.json();
    ensureIds(CURRENT_WORD); // APPLY ID FIX
    if (CURRENT_WORD.senses) {
        renderEntry($('#entryPanel'), CURRENT_WORD);
    } else {
        $('#entryPanel').innerHTML = `<div style="padding:20px;">Data Error: No senses found</div>`;
    }
  } catch(e) { $('#entryPanel').innerHTML = `<div style="padding:20px; color:var(--muted)">Error loading word.<br><small>${e.message}</small></div>`; }
}

function renderEntry(target, word, isReview = false, cardData = null, isBrowserEdit = false) {
  if (!word || !word.senses) { target.innerHTML = "Error: Word data missing."; return; }

  const isEditing = (SELECTION_MODE && EDIT_CARD_ID) || isBrowserEdit;
  const groups = {}; const groupOrder = [];
  word.senses.forEach(s => { const label = normalizePos(s.attr || word.pos || 'General'); if(!groups[label]) { groups[label] = []; groupOrder.push(label); } groups[label].push(s); });

  const isLocked = localStorage.getItem('lex_always_expand') === 'true';
  const showAll = isLocked || TEMP_EXPANDED || SELECTION_MODE || isReview || isBrowserEdit;
  
  const usedSenseIds = new Set();
  if (SELECTION_MODE && !ALLOW_DUPLICATES && !isEditing) { state.deck.forEach(c => { if (c.lemma === word.lemma && c.deck === state.selectedDeckForAdd) c.senses.forEach(sid => usedSenseIds.add(sid)); }); }

  const visibleIDs = new Set();
  if (isReview && cardData) { 
    // Handle mix of int/string IDs from legacy saves
    cardData.senses.forEach(id => visibleIDs.add(id.toString())); 
  } else {
    groupOrder.forEach(k => { if(groups[k].length > 0) visibleIDs.add(groups[k][0].id.toString()); });
    let count = visibleIDs.size;
    if(count < 3) {
      for(const k of groupOrder) {
        for(const s of groups[k]) { 
            const sid = s.id.toString();
            if(!visibleIDs.has(sid)) { visibleIDs.add(sid); count++; } 
            if(count >= 3) break; 
        }
        if(count >= 3) break;
      }
    }
  }

  let bodyHtml = '';
  let totalSenses = 0;
  groupOrder.forEach(k => { totalSenses += groups[k].length; });
  
  const wrapperClass = isReview ? 'review-content' : '';
  bodyHtml += `<div class="${wrapperClass}">`;

  groupOrder.forEach(k => {
    if(isReview && !groups[k].some(s => visibleIDs.has(s.id.toString()))) return;
    
    bodyHtml += `<div class="pos-group-header">${k}</div>`;
    groups[k].forEach(s => {
      const sid = s.id.toString();
      if (isReview && !visibleIDs.has(sid)) return;
      
      const isHidden = !isReview && !SELECTION_MODE && !isBrowserEdit && (!showAll && !visibleIDs.has(sid));
      const isUsed = usedSenseIds.has(s.id);
      let exVisible = true;
      if (isReview && cardData && cardData.hiddenEx && cardData.hiddenEx.includes(s.ex_id)) exVisible = false;

      if (isReview) {
        // CLEAN MODE (Pure HTML)
        bodyHtml += `<div class="def-card"><span class="def-block">${s.def}</span>${(s.ex && exVisible) ? `<span class="example-block">${s.ex}</span>` : ''}</div>`;
      } else {
        // INTERACTIVE MODE
        let chkAttr = ''; 
        const isSelectedInCard = isEditing && cardData && cardData.senses.some(id => id.toString() === sid);
        if (SELECTION_MODE || isBrowserEdit) { 
            if (isSelectedInCard) chkAttr = 'checked'; else if (isUsed && !isBrowserEdit) chkAttr = 'disabled'; else if (!isEditing && !isBrowserEdit) chkAttr = 'checked'; 
        }
        const senseChkHtml = (SELECTION_MODE || isBrowserEdit) ? `<input type="checkbox" class="chk chk-sense" value="${s.id}" ${chkAttr} onchange="toggleSense(this, '${s.ex_id}')">` : '';
        let exChkAttr = 'checked';
        if (SELECTION_MODE || isBrowserEdit) { 
            if (isEditing && cardData && cardData.hiddenEx && cardData.hiddenEx.includes(s.ex_id)) exChkAttr = ''; 
            if (chkAttr.includes('disabled')) exChkAttr = 'disabled'; 
            if (isEditing && cardData && !isSelectedInCard) exChkAttr = 'disabled'; 
        }
        const exChkHtml = (SELECTION_MODE || isBrowserEdit) ? `<input type="checkbox" class="chk chk-ex" id="chk_ex_${s.ex_id}" value="${s.ex_id}" ${exChkAttr}>` : '';
        bodyHtml += `<div class="def-card ${isUsed && !isEditing && !isBrowserEdit ? 'disabled' : ''} ${isHidden ? 'hidden-sense' : ''}"><div class="def-row">${senseChkHtml}<div class="def-block">${s.def}</div></div>${s.ex ? `<div class="example-row" id="row_ex_${s.ex_id}">${exChkHtml}<div class="example-text">${s.ex}</div></div>` : ''}</div>`;
      }
    });
  });

  const noteText = state.notes[word.lemma] || '';
  if (SELECTION_MODE || isBrowserEdit) {
    const includeNotes = (cardData && cardData.includeNotes);
    // REMOVED LABEL TEXT - Just Checkbox
    bodyHtml += `<div class="notes-section"><label class="notes-label"><div style="display:flex; align-items:center; gap:6px;"><input type="checkbox" id="chkIncludeNotes" ${includeNotes ? 'checked' : ''} class="chk" title="Include Notes"></div></label><textarea class="notes-area" oninput="saveNote('${word.lemma}', this.value)">${noteText}</textarea></div>`;
  } else if (isReview) {
    // Only show notes if they exist AND are included
    if(cardData && cardData.includeNotes && noteText.trim() !== '') { 
      bodyHtml += `<div class="notes-section"><div class="notes-label">My Notes</div><div style="font-style:italic; white-space:pre-wrap;">${noteText}</div></div>`; 
    }
  } else {
    bodyHtml += `<div class="notes-toggle" onclick="toggleNotes(this)"><span>+ Add Notes</span></div><div class="notes-container"><textarea class="notes-area" placeholder="Add personal notes..." oninput="saveNote('${word.lemma}', this.value)">${noteText}</textarea></div>`;
  }
  
  bodyHtml += `</div>`; // Close wrapper

  if (isBrowserEdit) {
      target.innerHTML = `<div class="entry-body">${bodyHtml}</div>`;
      return;
  }

  let btnHtml = ''; let deckSelectHtml = '';
  if (!isReview) {
    if (SELECTION_MODE) {
      const deckOpts = state.decks.map(d => `<option value="${d}" ${d===state.selectedDeckForAdd?'selected':''}>${d}</option>`).join('');
      deckSelectHtml = isEditing ? `<span class="pill">Editing Card</span>` : `<div style="display:flex; align-items:center; gap:10px;"><select id="saveDeckSelect" class="input" style="padding:4px; height:32px;" onchange="changeAddDeck(this.value)">${deckOpts}</select><button class="btn" style="padding:0 8px; height:32px;" onclick="createNewDeckInPlace()">New</button><label style="font-size:12px; display:flex; gap:4px; align-items:center; cursor:pointer; user-select:none;"><input type="checkbox" onchange="toggleAllowDups(this.checked)" ${ALLOW_DUPLICATES?'checked':''} class="chk"> Allow Dups</label></div>`;
      const saveAction = isEditing ? `saveEdit()` : `saveSelection()`;
      btnHtml = `<div style="display:flex; gap:8px;"><button class="btn" style="height:32px;" onclick="cancelSelection()">Cancel</button><button class="btn-circle active" onclick="${saveAction}" title="Save">✓</button></div>`;
    } else {
      const existing = state.deck.find(c => c.lemma === word.lemma);
      btnHtml = `<button class="btn-circle ${existing ? 'added' : ''}" onclick="startSelection()" title="${existing ? 'Add another card' : 'Add to Review'}">${existing ? '✓' : '+'}</button>`;
    }
  }

  const hiddenCount = totalSenses - visibleIDs.size;
  const btnText = showAll ? 'Show Less' : `Show ${hiddenCount} More`;
  
  // FIX: Review Mode = Clean Container (No Header)
  if (isReview) {
      target.innerHTML = `<div class="entry-body">${bodyHtml}</div>`;
  } else {
      target.innerHTML = `<div class="entry-card ${SELECTION_MODE ? 'selection-mode' : ''}"><div class="entry-header"><div style="display:flex; justify-content:space-between; align-items:center;"><div style="display:flex; align-items:baseline; gap:10px;"><div class="lemma-text">${word.lemma}</div><span class="pill">${word.ipa || ''}</span>${deckSelectHtml}</div>${btnHtml}</div></div><div class="entry-body">${bodyHtml}</div>${(!isReview && !SELECTION_MODE && (totalSenses > 3 || showAll)) ? `<div class="expand-control"><button class="expand-btn" onclick="toggleExpand()">${btnText}</button><div class="lock-wrapper ${isLocked ? 'active' : ''}" onclick="toggleLock(this)"><div class="lock-icon"></div></div></div>` : ''}</div>`;
  }
}

function toggleNotes(el) { const c = el.nextElementSibling; if(c.classList.contains('open')) { c.classList.remove('open'); el.querySelector('span').textContent = "+ Add Notes"; } else { c.classList.add('open'); el.querySelector('span').textContent = "- Hide Notes"; c.querySelector('textarea').focus(); } }

// NEW TOGGLE LOGIC:
function flipCard() {
  if (window.getSelection().toString().length > 0) return; // Ignore selection clicks
  const card = $('#activeFlashcard');
  const controls = $('#reviewControls');
  
  if (card.classList.contains('flipped')) {
    card.classList.remove('flipped');
    controls.classList.remove('visible');
  } else {
    card.classList.add('flipped');
    controls.classList.add('visible');
  }
}

function toggleExpand() { 
  if (localStorage.getItem('lex_always_expand') === 'true') {
    localStorage.setItem('lex_always_expand', 'false');
    TEMP_EXPANDED = false; 
  } else {
    TEMP_EXPANDED = !TEMP_EXPANDED; 
  }
  renderEntry($('#entryPanel'), CURRENT_WORD); 
}

function toggleLock(el) { const c = localStorage.getItem('lex_always_expand') === 'true'; localStorage.setItem('lex_always_expand', (!c).toString()); renderEntry($('#entryPanel'), CURRENT_WORD); }
function saveNote(lemma, text) { state.notes[lemma] = text; localStorage.setItem('lex_v12_notes', JSON.stringify(state.notes)); }
function toggleSense(chk, exId) { const exChk = document.getElementById(`chk_ex_${exId}`); const exRow = document.getElementById(`row_ex_${exId}`); if(exChk && exRow) { if (!chk.checked) { exChk.checked = false; exChk.disabled = true; exRow.classList.add('disabled'); } else { exChk.disabled = false; exRow.classList.remove('disabled'); exChk.checked = true; } } }
function startSelection() {
  SELECTION_MODE = true;
  const saved = localStorage.getItem('lex_v9_last_add_deck');
  if (saved && state.decks.includes(saved)) {
    state.selectedDeckForAdd = saved;
  } else {
    state.selectedDeckForAdd = state.decks[0];
  }
  renderEntry($('#entryPanel'), CURRENT_WORD);
}

function cancelSelection() { 
  SELECTION_MODE = false; 
  EDIT_CARD_ID = null; 
  renderEntry($('#entryPanel'), CURRENT_WORD); 
  
  if (RETURN_TO_VIEW === 'review') {
    quitSession(); 
    $('[data-tab="review"]').click();
    $('#reviewSession').style.display = 'block'; 
    $('#deckDashboard').style.display = 'none';
  } else if (RETURN_TO_VIEW === 'browser') {
    $('[data-tab="review"]').click();
    showBrowser(); 
  }
  RETURN_TO_VIEW = null;
}

function changeAddDeck(val) {
  state.selectedDeckForAdd = val;
  localStorage.setItem('lex_v9_last_add_deck', val);
  renderEntry($('#entryPanel'), CURRENT_WORD);
}
function toggleAllowDups(val) { ALLOW_DUPLICATES = val; renderEntry($('#entryPanel'), CURRENT_WORD); }
function saveSelection() { const selectedSenses = Array.from(document.querySelectorAll('.chk-sense:checked:not(:disabled)')).map(cb => cb.value); if (selectedSenses.length === 0) { showToast("Select at least one definition"); return; } const hiddenEx = []; document.querySelectorAll('.chk-ex:not(:disabled)').forEach(cb => { if (!cb.checked) hiddenEx.push(cb.value); }); const newCard = { id: Date.now() + Math.random().toString().slice(2,5), lemma: CURRENT_WORD.lemma, deck: state.selectedDeckForAdd, senses: selectedSenses, hiddenEx: hiddenEx, includeNotes: $('#chkIncludeNotes').checked, due: Date.now(), interval: 0, factor: 2.5 }; state.deck.push(newCard); localStorage.setItem('lex_v9_deck', JSON.stringify(state.deck)); cancelSelection(); updateDashboard(); showToast("Card saved"); }

function saveEdit() { 
  const selectedSenses = Array.from(document.querySelectorAll('.chk-sense:checked:not(:disabled)')).map(cb => cb.value); 
  if (selectedSenses.length === 0) { showToast("Select at least one definition"); return; } 
  const hiddenEx = []; 
  document.querySelectorAll('.chk-ex:not(:disabled)').forEach(cb => { if (!cb.checked) hiddenEx.push(cb.value); }); 
  
  const cardIdx = state.deck.findIndex(c => c.id == EDIT_CARD_ID); 
  if(cardIdx !== -1) { 
    state.deck[cardIdx].senses = selectedSenses; 
    state.deck[cardIdx].hiddenEx = hiddenEx; 
    state.deck[cardIdx].includeNotes = $('#chkIncludeNotes').checked; 
    localStorage.setItem('lex_v9_deck', JSON.stringify(state.deck)); 
  } 
  
  showToast("Card updated");
  
  SELECTION_MODE = false; 
  EDIT_CARD_ID = null;
  
  if (RETURN_TO_VIEW === 'review') {
    $('[data-tab="review"]').click();
    loadReviewCard(); 
  } else if (RETURN_TO_VIEW === 'browser') {
    $('[data-tab="review"]').click();
    showBrowser(); 
  } else {
    renderEntry($('#entryPanel'), CURRENT_WORD);
  }
  RETURN_TO_VIEW = null;
}

function updateDashboard() { const sel = $('#dashboardDeckSelect'); if(!sel) return; const deckName = sel.value || state.decks[0]; const deckCards = state.deck.filter(c => c.deck === deckName && !PENDING_DELETES[c.id]); $('#dashDueCount').textContent = deckCards.filter(c => c.due <= Date.now()).length; $('#dashTotalCount').textContent = deckCards.length; 
    const btnContainer = $('#dashboardActionBtn');
    if (deckCards.filter(c => c.due <= Date.now()).length > 0) {
        btnContainer.innerHTML = `<button class="btn primary" onclick="startSession(false)">Start Review</button>`;
    } else {
        btnContainer.innerHTML = `<button class="btn" onclick="startSession(true)">Review More</button>`;
    }
}

function showBrowser() { 
    $('#deckDashboard').style.display = 'none'; 
    $('#deckBrowser').style.display = 'block'; 
    filterBrowser(''); 
    $('#editorContent').style.display = 'none';
    $('#editorPlaceholder').style.display = 'flex';
    EDIT_CARD_ID = null;
}

function closeBrowser() {
    $('#deckBrowser').style.display = 'none';
    $('#deckDashboard').style.display = 'block'; 
}

function filterBrowser(q) {
    const deckName = $('#dashboardDeckSelect').value;
    const cards = state.deck.filter(c => c.deck === deckName && !PENDING_DELETES[c.id] && c.lemma.toLowerCase().includes(q.toLowerCase()));
    $('#cardList').innerHTML = cards.map(c => `<li onclick="loadCardInBrowser('${c.id}')" id="card_li_${c.id}"><span>${c.lemma}</span><span style="color:var(--muted); font-size:11px;">${new Date(c.due).toLocaleDateString()}</span></li>`).join('');
}

async function loadCardInBrowser(id) {
    const card = state.deck.find(c => c.id == id);
    if(!card) return;

    document.querySelectorAll('#cardList li').forEach(li => li.classList.remove('selected'));
    $(`#card_li_${id}`).classList.add('selected');

    $('#editorPlaceholder').style.display = 'none';
    $('#editorContent').style.display = 'flex';
    
    EDIT_CARD_ID = id;
    $('#editorFront').textContent = card.lemma;

    try {
        const r = await fetch(`${API_BASE}/word/${card.lemma}`);
        if(!r.ok) throw new Error("Word not found");
        const wordData = await r.json();
        ensureIds(wordData); // Apply ID Fix
        if (wordData.senses) {
            renderEntry($('#editorBack'), wordData, false, card, true); 
        }
    } catch(e) {
        $('#editorBack').innerHTML = `<div style="color:var(--danger); padding:20px;">Error loading word data.</div>`;
    }
}

function saveCardFromEditor() {
    if(!EDIT_CARD_ID) return;
    const container = $('#editorBack');
    const selectedSenses = Array.from(container.querySelectorAll('.chk-sense:checked:not(:disabled)')).map(cb => cb.value); 
    if (selectedSenses.length === 0) { showToast("Select at least one definition"); return; } 
    const hiddenEx = []; 
    container.querySelectorAll('.chk-ex:not(:disabled)').forEach(cb => { if (!cb.checked) hiddenEx.push(cb.value); }); 

    const cardIdx = state.deck.findIndex(c => c.id == EDIT_CARD_ID); 
    if(cardIdx !== -1) { 
        state.deck[cardIdx].senses = selectedSenses; 
        state.deck[cardIdx].hiddenEx = hiddenEx; 
        state.deck[cardIdx].includeNotes = container.querySelector('#chkIncludeNotes').checked; 
        localStorage.setItem('lex_v9_deck', JSON.stringify(state.deck)); 
        showToast("Card saved");
    }
}

function deleteCardFromEditor() {
    if(!EDIT_CARD_ID) return;
    if(confirm("Delete this card forever?")) {
        state.deck = state.deck.filter(c => c.id !== EDIT_CARD_ID);
        localStorage.setItem('lex_v9_deck', JSON.stringify(state.deck));
        filterBrowser($('#browserSearch').value);
        $('#editorContent').style.display = 'none';
        $('#editorPlaceholder').style.display = 'flex';
        EDIT_CARD_ID = null;
        updateDashboard();
        showToast("Card deleted");
    }
}

function showToast(msg, actionText = null, actionCallback = null) { const t = document.createElement('div'); t.className = 'toast'; t.innerHTML = `<span>${msg}</span>`; if(actionText) { const act = document.createElement('span'); act.className = 'toast-action'; act.textContent = actionText; act.onclick = () => { actionCallback(); t.remove(); }; t.appendChild(act); } $('#toastContainer').appendChild(t); setTimeout(() => { if(t.parentNode) t.remove(); }, 4000); }
function undoLastAction() { const last = ACTION_STACK.pop(); if(!last) return showToast("Nothing to undo"); if (last.type === 'rate') { state.idx = last.idx; const cardIdx = state.deck.findIndex(c => c.id === last.cardId); if(cardIdx !== -1) { state.deck[cardIdx] = last.oldData; localStorage.setItem('lex_v9_deck', JSON.stringify(state.deck)); } loadReviewCard(); showToast("Rating undone"); } else if (last.type === 'soft_delete') { clearTimeout(PENDING_DELETES[last.id]); delete PENDING_DELETES[last.id]; showBrowser(); showToast("Deletion undone"); } }

function startSession(cramMode = false) { 
  const deckName = $('#dashboardDeckSelect').value; 
  state.currentReviewDeck = deckName; 
  state.cramMode = cramMode; 

  let cards = state.deck.filter(c => c.deck === deckName && !PENDING_DELETES[c.id]); 
  
  if (cramMode) {
    cards = cards.filter(c => c.due > Date.now()).sort((a,b) => a.due - b.due).slice(0, 20); 
  } else {
    cards = cards.filter(c => c.due <= Date.now()); 
  }
  
  if(cards.length === 0 && !cramMode) return showToast("No cards due");
  if(cards.length === 0 && cramMode) return showToast("No future cards to review");

  state.queue = cards; 
  state.idx = 0; 
  $('#deckDashboard').style.display = 'none'; 
  $('#reviewSession').style.display = 'block'; 
  loadReviewCard(); 
}

function quitSession() { $('#reviewSession').style.display = 'none'; $('#deckDashboard').style.display = 'block'; updateDashboard(); }
async function loadReviewCard() { const card = state.queue[state.idx]; $('#reviewProgress').textContent = `${state.idx + 1} / ${state.queue.length}`; $('#activeFlashcard').classList.remove('flipped'); $('#reviewControls').classList.remove('visible'); $('#cardFrontLemma').textContent = card.lemma; const r = await fetch(`${API_BASE}/word/${card.lemma}`); const wordData = await r.json(); ensureIds(wordData); const allIds = wordData.senses.map(s => s.id); const cardIndices = card.senses.map(sid => allIds.indexOf(sid) + 1).filter(i => i > 0).sort((a,b)=>a-b); if (cardIndices.length < allIds.length) $('#cardFrontContext').textContent = `(Senses ${cardIndices.join(', ')})`; else $('#cardFrontContext').textContent = ''; const factor = card.factor || 2.5; const ivl = card.interval || 0; const fmt = (d) => d < 1 ? '1m' : Math.round(d) + 'd'; $('#time-again').textContent = '1m'; $('#time-good').textContent = fmt(ivl === 0 ? 1 : ivl * factor); $('#time-easy').textContent = fmt(ivl === 0 ? 4 : ivl * factor * 1.3); renderEntry($('#cardBackContent'), wordData, true, card); }

function rateCard(rating) { 
  const card = state.queue[state.idx]; 
  const mainIdx = state.deck.findIndex(c => c.id === card.id); 
  
  if(mainIdx !== -1) { 
    const oldData = JSON.parse(JSON.stringify(state.deck[mainIdx])); 
    let item = state.deck[mainIdx]; 
    
    // SMART CRAM LOGIC
    if (state.cramMode) {
        if (rating === 1) { 
            // FAIL future card -> Reset to Now
            item.interval = 0; 
            item.due = Date.now(); 
            item.factor = Math.max(1.3, item.factor - 0.2); 
            localStorage.setItem('lex_v9_deck', JSON.stringify(state.deck)); 
        }
    } else {
        // STANDARD MODE LOGIC
        if (rating === 1) { item.interval = 0; item.due = Date.now() + 60000; item.factor = Math.max(1.3, item.factor - 0.2); } 
        else if (rating === 3) { item.interval = item.interval === 0 ? 1 : item.interval * item.factor; item.due = Date.now() + (item.interval * 86400000); } 
        else if (rating === 5) { item.interval = item.interval === 0 ? 4 : item.interval * item.factor * 1.3; item.due = Date.now() + (item.interval * 86400000); item.factor += 0.15; } 
        localStorage.setItem('lex_v9_deck', JSON.stringify(state.deck)); 
    }
    
    ACTION_STACK.push({ type: 'rate', cardId: card.id, oldData: oldData, idx: state.idx }); 
  } 
  
  state.idx++; 
  if(state.idx < state.queue.length) loadReviewCard(); 
  else quitSession(); 
}

async function editCurrentCard() { 
  const card = state.queue[state.idx]; 
  RETURN_TO_VIEW = 'review';
  $('[data-tab="home"]').click(); 
  await selectWord(card.lemma); 
  
  SELECTION_MODE = true; 
  EDIT_CARD_ID = card.id; 
  renderEntry($('#entryPanel'), CURRENT_WORD, false, card); 
}

function deleteCurrentCard() { const card = state.queue[state.idx]; if(confirm("Delete this card forever?")) { state.deck = state.deck.filter(c => c.id !== card.id); localStorage.setItem('lex_v9_deck', JSON.stringify(state.deck)); state.queue.splice(state.idx, 1); if(state.idx < state.queue.length) loadReviewCard(); else quitSession(); } }

function setupTabs() { 
  document.querySelectorAll('#mainNav a').forEach(a => { 
    a.onclick = () => { 
      if(a.dataset.tab === 'home') { goHome(); return; } 
      
      document.querySelectorAll('#mainNav a').forEach(l => l.classList.remove('active')); 
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active')); 
      a.classList.add('active'); 
      if(document.getElementById(`tab-${a.dataset.tab}`)) document.getElementById(`tab-${a.dataset.tab}`).classList.add('active'); 
      
      if(a.dataset.tab === 'review') { 
        $('#landingLayer').style.display = 'none'; 
        $('#dictionaryView').classList.remove('active');
        updateDashboard(); 
      } 
    }; 
  }); 
}

function setupSearch() {
  const inputs = [$('#searchInput'), $('#landingSearch')];
  inputs.forEach(input => {
    input.oninput = (e) => {
      const q = e.target.value.toLowerCase().trim();
      const isLanding = input.id === 'landingSearch';
      const targetList = isLanding ? $('#landingResults') : $('#resultsList');
      const targetCard = isLanding ? $('#centerSearchContainer') : $('#resultsCard');

      if (!q) {
        if (isLanding) targetList.style.display = 'none';
        else targetCard.style.display = 'none';
        return;
      }

      // Filter and Rank
      const filtered = LEXICON_INDEX.filter(l => l.toLowerCase().includes(q))
        .sort((a, b) => {
          const aLow = a.toLowerCase();
          const bLow = b.toLowerCase();

          // Exact match priority
          if (aLow === q && bLow !== q) return -1;
          if (bLow === q && aLow !== q) return 1;

          // Starts-with priority
          if (aLow.startsWith(q) && !bLow.startsWith(q)) return -1;
          if (bLow.startsWith(q) && !aLow.startsWith(q)) return 1;

          // Length priority
          if (aLow.length !== bLow.length) return aLow.length - bLow.length;

          // Alphabetical fallback
          return aLow.localeCompare(bLow);
        })
        .slice(0, 8);

      if (isLanding) targetList.style.display = 'block';
      else targetCard.style.display = 'block';

      targetList.innerHTML = filtered.map(l => 
        `<div class="result-item" onclick="selectWord('${l}')">${l}</div>`
      ).join('');
    };
  });
}

function createNewDeckInPlace() { const name = prompt("New Deck Name:"); if (name && !state.decks.includes(name)) { state.decks.push(name); localStorage.setItem('lex_v9_decks', JSON.stringify(state.decks)); populateDeckSelects(); setTimeout(() => { $('#dashboardDeckSelect').value = name; updateDashboard(); }, 0); } }
function populateDeckSelects() { const opts = state.decks.map(d => `<option value="${d}">${d}</option>`).join(''); if($('#dashboardDeckSelect')) $('#dashboardDeckSelect').innerHTML = opts; }
function setupShortcuts() { document.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undoLastAction(); return; } if ($('#reviewSession').style.display === 'block') { if (e.key === ' ') { e.preventDefault(); if (!$('#activeFlashcard').classList.contains('flipped')) flipCard(); } else if ($('#activeFlashcard').classList.contains('flipped')) { if (e.key === '1') rateCard(1); if (e.key === '2') rateCard(3); if (e.key === '3') rateCard(5); if (e.key.toLowerCase() === 'e') editCurrentCard(); if (e.key === 'Backspace') deleteCurrentCard(); } } }); }

init();
</script>
</body>
</html>
